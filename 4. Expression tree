ASSIGNMENT NO: 4
TITLE: TO CONSTRUCT AN EXPRESSION TREE FROM THE GIVEN PREFIX EXPRESSION
PROBLEM STATEMENT: -
Construct an expression tree from the given prefix expression eg. +--a*bc/def and traverse it using post
order traversal (non recursive) and then delete the entire tree



#include<iostream>
#include<stack>
#include<cctype>
using namespace std;

struct Node {
    char data;
    Node* left;
    Node* right;
    Node(char value) {
        data = value;
        left = right = nullptr;
    }
};

Node* tree(string prefix) {
    stack<Node*> st;
    for (int i = prefix.length() - 1; i >= 0; i--) {
        Node* newNode = new Node(prefix[i]);
        if (isalpha(prefix[i])) {
            st.push(newNode);
        } else {
            if (!st.empty()) {
                newNode->right = st.top(); st.pop();
            }
            if (!st.empty()) {
                newNode->left = st.top(); st.pop();
            }
            st.push(newNode);
        }
    }
    return st.top();
}

void postorder(Node* root) {
    if (root == nullptr) return;
    stack<Node*> s1, s2;
    s1.push(root);
    while (!s1.empty()) {
        Node* curr = s1.top(); s1.pop();
        s2.push(curr);
        if (curr->left) s1.push(curr->left);
        if (curr->right) s1.push(curr->right);
    }
    while (!s2.empty()) {
        cout << s2.top()->data << " ";
        s2.pop();
    }
    cout << endl;
}

void deleteTree(Node*& root) {
    if (root == nullptr) return;
    stack<Node*> s;
    s.push(root);
    while (!s.empty()) {
        Node* curr = s.top(); s.pop();
        if (curr->left) s.push(curr->left);
        if (curr->right) s.push(curr->right);
        delete curr;
    }
    root = nullptr;
}

int main() {
    string prefix;
    cout << "Enter Prefix: ";
    cin >> prefix;
    Node* root = tree(prefix);
    cout << "Postorder: ";
    postorder(root);
    deleteTree(root);
    cout << "Tree deleted." << endl;
    return 0;
}
